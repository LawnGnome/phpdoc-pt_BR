<?xml version="1.0" encoding="UTF-8"?>
<!-- EN-Revision: 1.27 Maintainer: narigone Status: ready -->
<appendix xml:id="migration" xmlns="http://docbook.org/ns/docbook">
 <title>Migrando do PHP/FI 2 para o PHP 3</title>

 <section xml:id="migration.about">
  <title>Sobre as incompatibilidades no 3.0</title>

  <simpara>
   PHP 3.0 foi re-escrito do zero. Tem um avaliador melhor
   que é muito mais robusto e consistente que o do 2.0. 3.0 também é
   significativamente mais rápido, e usa menos memória. No entanto, algumas
   dessas melhoras não foram possíveis sem mudanças de
   compatibilidade, tanto em sintaxe quanto em funcionalidade.
  </simpara>

  <simpara>
   Além disso, os desenvolvedores do PHP tentaram limpar tanto a 
   sintaxe quanto a semântica do PHP na versão 3.0, e isso também causou algumas
   incompatibilidades. A longo prazo, nós acreditamos que essas mudanças
   são para melhor.
  </simpara>

  <simpara>
   Esse capítulo tentará guiá-lo pelas incompatibilidades
   que você encontrará quando mudar do PHP/FI 2.0 para PHP 3.0 e ajudá-lo
   a resolvê-las. Novas capacidades não são mencionadas aqui, a não ser
   quando necessário.
  </simpara>

  <simpara>
   Existe um programa de conversão que pode converter automaticamente seus
   scripts velhos do PHP/FI 2.0. Ele pode ser encontrado no 
   subdiretório <filename class="directory">convertor</filename> da 
   distribuição do PHP 3.0. No entanto, esse programa apenas pega mudanças de 
   sintaxe então você deve ler esse capítulo cuidadosamente mesmo assim.
  </simpara>
 </section>

 <section xml:id="migration.old-function">
  <title><literal>old_function</literal></title>
  <simpara>
   A instrução <literal>old_function</literal> permite que você 
   declare uma função usando uma sintaxe idêntica a do PHP/FI2 (exceto que você
   deve substituir 'function' por 'old_function').
  </simpara>
  <simpara>
   Isso é uma característica depreciada, e só deve ser usada pelo
   convertor PHP/FI2-&gt;PHP 3.
  </simpara>
  <warning>
   <para>
    Funções declaradas como <literal>old_function</literal> não podem ser
    chamadas a partir do código interno do PHP. Entre outras coisas, isso significa
    que você não pode usá-las em funções como 
    <function>usort</function>, <function>array_walk</function>, e
    <function>register_shutdown_function</function>. Você pode
    contornar essa limitação escrevendo uma função wrapper (em formato
    do PHP 3) para chamar a <literal>old_function</literal>.
   </para>
  </warning>
 </section>
 
 <section xml:id="migration.startendtags">
  <title>Tags de início e fim</title>

  <para>
   A primeira coisa que você provavelmente notará é que as tags de início e fim
   de código do PHP mudaram. O formato velho <literal>&lt;? &gt;</literal> foi
   substituído por três formatos novos possíveis:
   <example>
    <title>Migração: tags velhas de início e fim</title>
    <programlisting role="php">
<![CDATA[
<? echo "Isso é um código PHP/FI 2.0.\n"; >
]]>
    </programlisting>
   </example>
   A partir da versão 2.0, PHP/FI também suporta essa variação:
   <example>
    <title>Migração: primeira forma nova de tags de início e fim</title>
    <programlisting role="php">
<![CDATA[
<? echo "Isso é um código PHP 3.0!\n"; ?>
]]>
    </programlisting>
   </example>
   
   Perceba que a tar de fim agora consiste de um ponto de interrogação e um
   sinal de maior que ao invés de apenas o sinal de maior que. No entanto, se
   você planejar usar XML no seu servidor, você ter problemas com
   essa primeira nova variante, porque o PHP pode tentar executar o 
   documento XML como código PHP. Por isso, a
   seguinte variação foi introduzida:

   <example>
    <title>Migração: segunda forma nova de tags de início e fim</title>
    <programlisting role="php">
<![CDATA[
<?php echo "Isso é um código PHP 3.0!\n"; ?>
]]>
    </programlisting>
   </example>

   Algumas pessoas tiveram problemas com editores que não entendem
   o processamento de tags de instrução. Microsoft FrontPage é um
   desses editores, e como uma forma de contornar isso, a seguinte variação
   foi introduzida também:

   <example>
    <title>Migração: terceira forma nova de tags de início e fim</title>
    <programlisting role="php">
<![CDATA[
<script language="php">

  echo "Isso é um código PHP 3.0!\n";

</script>
]]>
    </programlisting>
   </example>
  </para>
 </section>

 <section xml:id="migration.if-endif">
  <title>sintaxe de if..endif</title>

  <para>
   A maneira 'alternativa' de escrever instruções do tipo if/elseif/else usando if();
   elseif(); else; endif; não pode ser implementada eficientemente sem
   acrescentar uma grande quantidade de complexidade ao avaliador 3.0. Por isso,
   a sintaxe foi modificada:
   <example>
    <title>Migração: sintaxe velha de if..endif</title>
    <programlisting role="php">
<![CDATA[
if ($foo);
    echo "yep\n";
elseif ($bar);
    echo "almost\n";
else;
    echo "nope\n";
endif;
]]>
    </programlisting>
   </example>
   <example>
    <title>Migração: nova sintaxe de if..endif</title>
    <programlisting role="php">
<![CDATA[
if ($foo):
    echo "yep\n";
elseif ($bar):
    echo "almost\n";
else:
    echo "nope\n";
endif;
]]>
    </programlisting>
   </example>

   Note que os ponto-e-vírgula foram substituídos por dois pontos em todas
   as instruções menos a que termina a expressão (endif).
  </para>
 </section>

 <section xml:id="migration.while">
  <title>sintaxe do while</title>
  <para>
   Assim como com if..endif, a sintaxe do while..endwhile foi alterada
   também:
   <example>
    <title>Migração: sintaxe velha de while..endwhile</title>
    <programlisting role="php">
<![CDATA[
while ($more_to_come);
    ...
endwhile;
]]>
    </programlisting>
   </example>
   <example>
    <title>Migração: nova sintaxe do while..endwhile</title>
    <programlisting role="php">
<![CDATA[
while ($more_to_come):
    ...
endwhile;
]]>
    </programlisting>
   </example>
  </para>
  <warning>
   <simpara>
    Se você usar a sintaxe velha de while..endwhile no PHP 3.0,
    você terá um loop infinito.
   </simpara>
  </warning>
 </section>

 <section xml:id="migration.expr">
  <title>Tipos de Expressões</title>
  <simpara>
   PHP/FI 2.0 usava o lado esquerdo das expressões para determinar qual tipo
   o resultado seria. PHP 3.0 leva os dois lados em consideração quando
   determina os tipos dos resultados, e isso pode causar que scripts do 2.0 se comportem
   inexperadamente no 3.0.
  </simpara>
  <para>
   Considere esse exemplo:
   <informalexample>
    <programlisting role="php">
<![CDATA[
$a[0]=5;
$a[1]=7;

$key = key($a);
while ("" != $key) {
    echo "$keyn";
    next($a);
}
]]>
    </programlisting>
   </informalexample>

   No PHP/FI 2.0, isso mostraria ambos os índices de $a. No PHP
   3.0, não mostraria nada. A razão para isso é que no PHP 2.0,
   porque o argumento da esquerda é uma string, uma comparação de string
   é feita, e de fato, <literal>""</literal> não é igual a
   <literal>"0"</literal>, e o loop continuou. No PHP 3.0,
   quando uma string é comparada a um inteiro, uma comparação de inteiros é
   feita (a string é convertida para um inteiro). Isso resulta em
   comparar <literal>atoi("")</literal> que é
   <literal>0</literal>, e <literal>variablelist</literal> que
   também é <literal>0</literal>, e uma vez que <literal>0==0</literal>, o
   loop não passa nenhuma vez.
  </para>
  <para>
   Consertar isso é simples. Substitua a instrução while com:
   <informalexample>
    <programlisting role="php">
<![CDATA[
while ((string)$key != "") {
]]>
    </programlisting>
   </informalexample>
  </para>
 </section>

 <section xml:id="migration.errors">
  <title>Mensagens de Erro mudaram</title>
  <simpara>
   PHP 3.0's error messages are usually more accurate than 2.0's were,
   but you no longer get to see the code fragment causing the error.
   You will be supplied with a file name and a line number for the
   error, though.
  </simpara>
 </section>

 <section xml:id="migration.booleval">
  <title>Short-circuited boolean evaluation</title>
  <simpara>
   No PHP 3.0, avaliação booleana é short-circuited. Isso significa que
   em uma expressão como <literal>(1 || test_me())</literal>, a
   função <function>test_me</function> não seria executada, uma vez
   que nada pode mudar o resultado da expressão depois do
   <literal>1</literal>.
  </simpara>

  <simpara>
   Isso é um pequeno problema de compatibilidade, mas pode causar 
   efeitos-colaterais inexperados.
  </simpara>
 </section>

 <section xml:id="migration.truefalse">
  <title>Valores de retorno de função &true;/&false;</title>
  <simpara>
   A maioria das funções foram re-escritas para que elas retornem &true;
   quando tiverem sucesso e &false; quando falharem, ao contrário de 0 e -1 no
   PHP/FI 2.0, respectivamente. O nove comportamento permite criação de 
   código mais lógico, como <literal>$fp = fopen("/your/file") or
   fail("darn!");</literal>. Por isso, PHP/FI 2.0 não tinha regras claras
   para o que as funções retornariam se falharem, a maioria desses
   scripts provavelmente terá de ser checada manualmenta após usar o
   converto do 2.0 para o 3.0.
  </simpara>
  <para>
   <example>
    <title>Migração do 2.0: valores de retorno, código velho</title>
    <programlisting role="php">
<![CDATA[
$fp = fopen($file, "r");
if ($fp == -1);
    echo("Could not open $file for reading<br />\n");
endif;
]]>
    </programlisting>
   </example>
   <example>
    <title>Migração do 2.0: valores de retorno, código novo</title>
    <programlisting role="php">
<![CDATA[
$fp = @fopen($file, "r") or print("Could not open $file for reading<br />\n");
]]>
    </programlisting>
   </example>
  </para>
 </section>

 <section xml:id="migration.other">
  <title>Outras incompatibilidades</title>

  <itemizedlist>
   <listitem><simpara>
    O módulo do Apache do PHP 3.0 não suporta versões do Apache
    anteriores ao 1.2. Apache 1.2 ou superior é necessário.
   </simpara></listitem>

   <listitem><simpara>
    <function>echo</function> não tem mais suporte a uma string de formato.
    Ao invés, use a função <function>printf</function>.
   </simpara></listitem>

   <listitem><simpara>
    No PHP/FI 2.0, um efeito-colateral da implementação causava que
    <literal>$foo[0]</literal> tinha o mesmo efeito de
    <literal>$foo</literal>. Isso não é verdade para o PHP 3.0.
   </simpara></listitem>

   <listitem>
    <simpara>
     Ler arrays com <literal>$array[]</literal> não é mais
     suportado.
    </simpara>
    <simpara>
     Isso é, você não pode percorrer um array em um loop que faz
     <literal>$data = $array[]</literal>.  Ao invés, use as funções
     <function>current</function> e <function>next</function>.
    </simpara>
    <simpara>
     Além disso, <literal>$array1[] = $array2</literal> não
     acrescenta valores de <literal>$array2</literal> ao
     <literal>$array1</literal>, mas acrescenta o
     <literal>$array2</literal> como último registro do
     <literal>$array1</literal>. Veja também suporte à arrays 
     multidimensionais.
    </simpara>
   </listitem>

   <listitem>
    <simpara>
     <literal>"+"</literal> não é mais sobrecarregado como um
     operador de concatenação de strings, ao invés disso, ele converte
     seus argumentos para um número e realiza a adição numérica. Use
     <literal>"."</literal> ao invés.
    </simpara>
   </listitem>
  </itemizedlist>

  <example>
   <title>Migração do 2.0: concatenação de strings</title>
   <programlisting role="php">
<![CDATA[
echo "1" + "1";
]]>
   </programlisting>
   <para> 
    No PHP 2.0 isso mostraria 11, no PHP 3.0 
    mostraria 2. Ao invés, use:
    <programlisting role="php">
<![CDATA[
echo "1"."1";
]]>
    </programlisting>
    <programlisting role="php">
<![CDATA[
$a = 1;
$b = 1;
echo $a + $b;
]]>
    </programlisting>
   </para>
   <para>
    Isso mostraria 2 tanto no PHP 2.0 quanto no 3.0.
    <programlisting role="php">
<![CDATA[
$a = 1;
$b = 1;
echo $a.$b;
]]>
    </programlisting>
    Isso mostrará 11 no PHP 3.0.
   </para>
  </example>
 </section>

</appendix>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
