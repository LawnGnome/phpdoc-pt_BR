<?xml version="1.0" encoding="utf-8"?>
<!-- EN-Revision: 324459 Maintainer: none Status: wip --><!-- CREDITS: brunoric -->
 <appendix xml:id="oop4" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
  <title>Classes e Objetos (PHP 4)</title>

  <sect1 xml:id="keyword.class">
   <title><literal>class</literal></title>
   <para>
    Uma classe é uma coleção de variáveis e funções trabalhando com estas
    variáveis. Variáveis são definidas com a palavra chave <literal>var</literal>
    e funções com a palavra chave <literal>function</literal>. Uma classe
    é definida utilizando a seguinte sintaxe:
   </para>
   <para>
    <informalexample>
     <programlisting>
<![CDATA[
<?php
class Cart {
    var $items;  // Itens no seu carrinho

    // Adiciona $num artigos com $artnr ao carrinho

    function add_item($artnr, $num) {
        $this->items[$artnr] += $num;
    }

    // Remove $num artigos de $artnr do seu carrinho

    function remove_item($artnr, $num) {
        if ($this->items[$artnr] > $num) {
            $this->items[$artnr] -= $num;
            return true;
        } elseif ($this->items[$artnr] == $num) {
            unset($this->items[$artnr]);
            return true;
        } else {
            return false;
        }
    }
}
?>
]]>
     </programlisting>
    </informalexample>
   </para>
 
   <para>
    Isto define a classe chamada <emphasis>Cart</emphasis> que consiste em um <emphasis>array</emphasis> associativo de artigos no carrinho e duas funções para adicionar e remover itens deste carrinho.
   </para>

   <warning>
    <simpara>
     Você <emphasis>não</emphasis> pode quebrar uma definição de classe, em múltiplos arquivos.
     Você também <emphasis>não</emphasis> pode quebrar uma definição de classe em múltiplos
     blocos de PHP, exceto que esta quebra se dê dentro da declaração de um método. O código a seguir não irá funcionar:
    </simpara>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class test {
?>
<?php
    function test() {
        print 'OK';
    }
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
    <simpara>
     Todavia, o código abaixo é permitido:
    </simpara>
    <para>
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class test {
    function test() {
        ?>
        <?php
        print 'OK';
    }
}
?>
]]>
      </programlisting>
     </informalexample>
    </para>
   </warning>

   <simpara>
    As seguintes notas de advertência são válidas para PHP 4.
   </simpara>
    
   <caution>
    <simpara>
     O nome <literal>stdClass</literal> é utilizado internamente pelo motor Zend
     e é reservado. Você não pode criar uma classe chamada <literal>stdClass</literal>
     em PHP.
    </simpara>
   </caution>
    
   <caution>
    <simpara>
      Os nomes de função <literal>__sleep</literal> e <literal>__wakeup</literal>
      são métodos mágicos no PHP. Você não pode ter métodos com estes nomes em nenhuma
      de suas classes a não ser que você queira se aproveitar da funcionalidade
      <emphasis>mágica</emphasis> associadada a eles. Veja abaixo mais informações.
    </simpara>
   </caution>
    
   <caution>
    <simpara>
      O PHP reserva todos os nomes de funções iniciados com <literal>__</literal>
      como mágicos. É recomendado que você não crie funções com <literal>__</literal>
      em PHP não ser que você queira se aproveitar da funcionalidade
      <emphasis>mágica</emphasis> associadada a eles.
    </simpara>
   </caution>

   <simpara>
    No PHP 4, não são permitidas inicializações de variáveis através da palavra-chave
    <literal>var</literal> com valores não constantes. Para inicializar variáveis com
    algum valor não constante, você precisa efetuar a atribuição de valores através do
    método construtor que é automaticamente executado na inicialização de um novo objeto.
    Veja o exemplo abaixo:
   </simpara>
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class Cart {
    /* Estas inicializações NÃO funcionam no PHP 4. */
    var $todays_date = date("Y-m-d");
    var $name = $firstname;
    var $owner = 'Fred ' . 'Jones';
    /* Arrays contendo valores constantes funcionarão. */
    var $items = array("VCR", "TV");
}

/* Esta é a maneira como deve ser feito no PHP4. */
class Cart {
    var $todays_date;
    var $name;
    var $owner;
    var $items = array("VCR", "TV");

    function Cart() {
        $this->todays_date = date("Y-m-d");
        $this->name = $GLOBALS['firstname'];
        /* etc... */
    }
}
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Classe são tipos, isto é, elas são modelos para objetos (variáveis). Para criar
    um objeto você deve atribuir a uma variável uma nova instância classe desejada
    utilizando o operador <literal>new</literal>.
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$cart = new Cart;
$cart->add_item("10", 1);

$another_cart = new Cart;
$another_cart->add_item("0815", 3);
?>
]]>
    </programlisting>
   </informalexample>
 
   <para>
    O código acima cria os objetos <varname>$cart</varname> e <varname>$another_cart</varname>,
    ambos da classe Cart. A função <literal>add_item()</literal> do objeto<varname>$cart</varname>
    está sendo chamada para adicionar um item do artigo de número 10 ao carrinho. Três items do
    artigo de número 0815 são adicionados ao carrinho <varname>$another_cart</varname>.
   </para>
   
   <para>
    Ambos, <varname>$cart</varname> e <varname>$another_cart</varname>, possuem as funções
    <literal>add_item()</literal>, <literal>remove_item()</literal> e a variável (propriedade)
    <varname>items</varname>. Estas são funções e variáveis distintas em cada objeto. Você pode
    pensar nos objetos como algo semelhante a diretórios em um sistema de arquivos. Em um sistema
    de arquivos você pode possuir dois (ou mais) diferentes arquivos chamados <filename>README.TXT</filename>,
    desde que estejam em diretórios diferentes. Assim como os diretórios onde você têm de utilizar 
    o nome completo do caminho para encontrar cada arquivo na hierarquia do sistema, você deve
    especificar o nome completo da função que você deseja chamar: em termos de PHP 4, o diretório
    raiz será o namespace global e o separador de pastas será <literal>-&gt;</literal>. Deste modo,
    os nomes <varname>$cart-&gt;items</varname> e <varname>$another_cart-&gt;items</varname> nomeiam
    suas variáveis diferentes. Note que a variável é chamada <varname>$cart-&gt;items</varname>, não
    <varname>$cart-&gt;$items</varname>, isto é a variável em PHP só possui um único dólar 
    (<literal>$</literal>).
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
// correto, um único $
$cart->items = array("10" => 1); 

// inválido, porque $cart->$items se torna $cart->""
$cart->$items = array("10" => 1);

// correto, mas pode ou não ser a real intençaõ:
// $cart->$myvar se torna $cart->items
$myvar = 'items';
$cart->$myvar = array("10" => 1);  
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Em uma definição de classe, você não sabe com qual nome seu objeto será
    instanciado em seu programa: quando a classe Cart foi escrita, não se sabia
    se o objeto iria se chamar <varname>$cart</varname>, <varname>$another_cart</varname>,
    ou qualquer outro nome. Desse modo você não pode escrever <varname>$cart-&gt;items</varname>
    no próprio código da classe Cart. Ao invés disso, para acessar as próprias funções e variáveis
    de uma classe de dentro da própria classe, você pode utilizar a pseudo-variável 
    <varname>$this</varname> a qual pode ser lida como 'meu(minha) próprio(a)' ou 'objeto corrente'.
    Assim, '<varname>$this-&gt;items[$artnr]</varname> += <varname>$num</varname>' pode ser lido
    como 'adicione <varname>$num</varname> ao contador <varname>$artnr</varname> de itens do meu próprio
    array' ou 'adicione <varname>$num</varname> ao contador <varname>$artnr</varname> de items do array do objeto corrente'.
   </para>

   <note>
    <para>
     A pseudo-variável <varname>$this</varname> geralmente não é definida se o método
     em questão é chamado estaticamente. Isto não é, no entanto, uma regra estrita pois caso 
     a chamada estática seja feita por meio de outro objeto <varname>$this</varname> será 
     definido como o objeto que está efetuando a chamada. Para ilustrar esta questão visualize
     o exemplo a seguir:
     <informalexample>
      <programlisting role="php">
<![CDATA[
<?php
class A
{
    function foo()
    {
        if (isset($this)) {
            echo '$this foi definido (';
            echo get_class($this);
            echo ")\n";
        } else {
            echo "\$this não foi definido.\n";
        }
    }
}

class B
{
    function bar()
    {
        A::foo();
    }
}

$a = new A();
$a->foo();
A::foo();
$b = new B();
$b->bar();
B::bar();
?>
]]>     
      </programlisting>
      &example.outputs;
      <screen>
<![CDATA[
$this foi definido (a)
$this não foi definido.
$this foi definido (b)
$this não foi definido.
]]>
      </screen>
     </informalexample>
    </para>
   </note>

   <note>
    <para>
    Existem algumas funções interessantes para manipular classes e objetos. Você pode
    querer dar uma olhada em <link linkend="ref.classobj">Funções para Classes/Objetos</link>.
    </para>
   </note>
  </sect1>
  
  <sect1 xml:id="keyword.extends">
   <title><literal>extends</literal></title>

   <para>
    Frequentemente você necessita de classes com variáveis e funções similares a outra
    classe existente. De fato é uma boa pratica definir classes genéricas que possam ser 
    reutilizadas em seus projetos, sendo estas adaptadas para cada necessidade específica.
    Para facilitar isto, classes podem ser extensões de outras classes. Uma classe estendida
    ou derivada tem todos os métodos (funções) e variáveis (propriedades/atributos) da classe 
    'mãe' (classe da qual se deriva). Isto se chama 'herança'. Não é possível remover variáveis
    ou métodos presentes na classe base. Uma classe estendida é sempre dependente de uma única
    classe 'mãe', ou seja, a herença múltipla presente em algumas outras linguagens orientadas
    não é suportada no PHP 4. Classes são estendidas utilizando-se a palavra-chave 
    '<literal>extends</literal>'.
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class Named_Cart extends Cart {
    var $owner;
  
    function set_owner ($name) {
        $this->owner = $name;
    }
}
?>
]]>
    </programlisting>
   </informalexample>
 
   <para>
    Isto define a classe Named_Cart que possui todas as variáveis e funções da classe
    Cart, além de também possuir, adicionalmente, a variável <varname>$owner</varname>
    e o método <literal>set_owner()</literal>. Você pode criar um objeto do tipo
    Named_Cart da maneira usual e agora pode atribuir seu <varname>$owner</varname>.
    Você pode ainda utilizar as funções presentes na classe Cart normalmente:
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
$ncart = new Named_Cart;    // Cria um objeto do tipo Named_Cart
$ncart->set_owner("kris");  // Atribui um valor para $owner
print $ncart->owner;        // Imprime o nome do dono ($owner) da classe
$ncart->add_item("10", 1);  // Funcionalidade herdada da classe Cart
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Isto é também chamado de ralação de parentes ou relação 'pai-filho'. Você cria uma 
    classe 'pai' e utiliza <literal>extends</literal> para criar outra classe baseada na
    classe 'pai': a classe filho. Você pode inclusive utilizar criar novas classes baseadas
    na classe 'filho'.
   </para>
   <note>
    <para>
     Classes devem ser definidas antes de serem utilizadas! Se você deseja que a classe
     <literal>Named_Cart</literal> estenda a classe
     <literal>Cart</literal>, vcoê precisa definir a classe
     <literal>Cart</literal> primeiro. Se você deseja criar outra classe chamada
     <literal>Yellow_named_cart</literal> baseada na classe 
     <literal>Named_Cart</literal> você deve definir a classe
     <literal>Named_Cart</literal> primeiro. Em resumo: a ordem que as classes são definidas
     é importante.
    </para>
   </note>
  </sect1>

  <sect1 xml:id="oop4.constructor">
   <title>Constructors</title>

   <para>
    Construtores são funções em uma classe que são automaticamente chamados
    quando você cria uma nova instância desta classe utilizando o operador
    <literal>new</literal>. Um método (função) se torna um construtor em PHP 4,
    quando ele possui o mesmo nome que sua classe. Se uma classe não tem método construtor,
    o construtor da classe base (classe 'pai') será então chamado se existir.
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class Auto_Cart extends Cart {
    function Auto_Cart() {
        $this->add_item("10", 1);
    }
}
?>
]]>
    </programlisting>
   </informalexample>
 
   <para>
    Isto define a classe Auto_Cart que é um Cart com a adição de um construtor
    que inicializa o carrinho com um item do artigo de número '10' toda vez
    que um novo Auto_Cart é criado utilizando "<literal>new</literal>". Construtores
    podem receber argumentos e estes argumentos podem ser opicionais, o que os tornam
    muito mais úteis. Para ser possível utilizar a classe sem parâmetros, todos os
    parâmetros do construtor devem ser criados como opicionais atribuindo-se valores
    padrões para os mesmos.
   </para>
 
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class Constructor_Cart extends Cart {
    function Constructor_Cart($item = "10", $num = 1) {
        $this->add_item ($item, $num);
    }
}
 
// Utilizando os valores padrões presentes no construtor
$default_cart = new Constructor_Cart;
 
// Setando novos parâmetros
$different_cart = new Constructor_Cart("20", 17);
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    Você também pode utilizar o operador <literal>@</literal> para 
    <emphasis>esconder</emphasis> os erros que eventualmente ocorrem
    na utilização do construtor (Ex.: <literal>@new</literal>) mas isto
    em geral não é uma boa prática.
   </para>

   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class A
{
    function A()
    {
        echo "Eu sou o construtor de A.<br />\n";
    }

    function B()
    {
        echo "Eu sou um método qualquer chamado B pertencente a classe A.<br />\n";
        echo "Eu não sou o construtor de A.<br />\n";
    }
}

class B extends A
{
}

// Isto irá chamar B() como o construtor de B.
$b = new B;
?>
]]>
    </programlisting>
   </informalexample>
   
   <para>
    O método (função) B() da classe A irá se tornar o construtor da classe B,
    apesar de que essa talvez não fosse a real intenção. O PHP 4 não se importa se
    o método foi definido na classe B ou se foi herdado.
   </para>
   
   <caution>
    <simpara>
     O PHP não chama automaticamente os construtores das classes bases (pais)
     em um construtor de uma classe derivada. É de sua responsabilidade propagar
     a chamada apropriadamente caso esta seja sua intenção.
    </simpara>
   </caution>
   
   <para>
    Destrutores são métodos (funções) que são chamadas automaticamente quando um objeto
    é destruido, seja via <function>unset</function> ou simplesmente por ter sua execução
    terminada. Não existem destrutores em PHP. Você pode utilizar 
    <function>register_shutdown_function</function> para simular a maioria dos efeitos dos
    destrutores.
   </para>
  </sect1>

 <sect1 xml:id="keyword.paamayim-nekudotayim"><!-- :-) -->
   <title>Operador de resolução de escopo (<literal>::</literal>)</title>

   <caution>
    <simpara>
     Isto é válido somente para o PHP 4 e versões posteriores.
    </simpara>
   </caution>

   <para>
    Algumas vezes é útil se referir a funções e variáveis em uma classe 'pai'
    ou se referir a funções em classes que ainda não possuem instâncias. O operador
    <literal>::</literal> é utilizado para isso.
   </para>
   
   <informalexample>
    <programlisting role="php">
<![CDATA[
<?php
class A {
    function example() {
        echo "Eu sou o método original A::example().<br />\n";
    }
}

class B extends A {
    function example() {
        echo "Eu sou o método redefinido B::example().<br />\n";
        A::example();
    }
}

// Não existe um objeto da classe A mas ainda sim o método 
// será executado e imprimirá
// Eu sou o método original A::example().<br />
A::example();

// Criando um objeto da classe B.
$b = new B;

// Isto irá imprimir
// Eu sou o método redefinido B::example().<br />
// Eu sou o método original A::example().<br />
$b->example();
?>
]]>
    </programlisting>
   </informalexample>

   <para>
    O exemplo acima chama o método <literal>example()</literal> presente na 
    classe A, mas não existe um objeto instanciado da classe A, desse modo
    nós não podemos escrever <literal>$a->example()</literal>. Ao invés disso
    podemos chamar <literal>example()</literal> como uma 'função de classe',
    ou seja, como uma função da própria classe e não de algum objeto (instância)
    da classe.
   </para>
   
   <para>
    Existem 'funções de classe' mas não existem 'variáveis de classe'. De fato, não
    existe nenhum objeto no momento da chamada. Assim, a 'função de classe' não pode
    utilizar-se de nenhuma das variáveis (propriedades) da classe (mas pode utilizar-se
    variáveis locais ou globais) e não pode possuir chamadas utilizando
    <varname>$this</varname>.
   </para>

   <para>
    No exemplo acima, a classe B redefine a função <literal>example()</literal>. 
    A definição original presente na classe A é sobrescrita e não está mais disponível,
    a não ser que você se refira explicitamente à implementação de 
    <literal>example()</literal> na classe A utilizando o operador <literal>::</literal>.
    Escreva <literal>A::example()</literal> para fazer isto (de fato, você poderia utilizar
    <literal>parent::example()</literal>, como demonstrado na seção seguinte).
   </para>
   
   <para>
    Neste contexto, existe um objeto corrente e este pode possuir variáveis.
    Assim, quando utilizado dentro de um método de um objeto, você pode utilizar
    <varname>$this</varname> bem como as variáveis de objeto.
   </para>

 </sect1>

 <sect1 xml:id="keyword.parent">
   <title><literal>parent</literal></title>

  <para>
   Você pode encontrar-se escrevendo códigos que se referem a variáveis
   e funções em classes pais. Isto é particularmente verdade se sua classe
   derivada é um refinamento ou especialização do código da classe pai.
  </para>
  
  <para>
   Ao invés de utilizar o nome literal da classe pai em seu código,
   você pode utilizar o nome especial <literal>parent</literal>, 
   o qual se refere ao nome da classe base utilizada em conjunto 
   da declaração <literal>extends</literal> em sua classe.
   Fazendo isto, você evita a utilização do nome da sua classe base
   em mais de um lugar, facilitando mudanças posteriores em sua 
   árvore de herança.
  </para>

  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
class A {
    function example() {
        echo "Eu sou A::example() e promovo funcionalidade básica.<br />\n";
    }
}

class B extends A {
    function example() {
        echo "Eu sou B::example() e promovo funcionalidade adicional.<br />\n";
        parent::example();
    }
}

$b = new B;

// Isto irá chamar B::example(), a qual irá chamar A::example().
$b->example();
?>
]]>
   </programlisting>
  </informalexample>
 </sect1>

 <sect1 xml:id="oop4.serialization">
  <title>Serialização de objetos - objetos na sessão</title>

  <para>
   A função <function>serialize</function> retorna uma <literal>string</literal>
   contendo uma representação de stream de bytes de qualquer valor que pode ser
   persistido em PHP. A função <function>unserialize</function> pode utilizar-se desta
   string para recriar o objeto original. Utilizando serialização para persistir (salvar)
   um objeto, salva todas as variáveis deste objeto. As funções em um objeto não serão
   persistidas, somente o nome da classe.
  </para>
  
  <para>
   Para ser capaz utilizar a função <function>unserialize</function> em um objeto
   a classe deste objeto precisa estar definida. Isto é, se você possui um objeto
   <varname>$a</varname> de uma classe A em <filename>page1.php</filename> e o serializa,
   você irá possuir uma string de referência para a classe A contendo os valores das 
   variáveis atribuídos em <varname>$a</varname>. Se você deseja ser capaz de deserializar
   isto em <filename>page2.php</filename>, recriando <varname>$a</varname> da classe A,
   a definição da classe A precisa estar presente em <filename>page2.php</filename>.
   Isto pode ser feito por exemplo ao se gravar a definição da classe A em um arquivo e 
   o incluí-lo em ambos os arquios 
   <filename>page1.php</filename> e <filename>page2.php</filename>.
  </para>
  
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
// classa.inc:
  
  class A {
      var $one = 1;
    
      function show_one() {
          echo $this->one;
      }
  }
  
// page1.php:

  include("classa.inc");
  
  $a = new A;
  $s = serialize($a);
  // grava $s em algum lugar onde page2.php possa acessá-lo.
  $fp = fopen("store", "w");
  fwrite($fp, $s);
  fclose($fp);

// page2.php:
  
  // isto é necesário para a deserialização ocorrer corretamente.
  include("classa.inc");

  $s = implode("", @file("store"));
  $a = unserialize($s);

  // agora utilize a função show_one() do objeto $a.  
  $a->show_one();
?>
]]>
   </programlisting>
  </informalexample>
  
  <para>
   Se você está utilizando sessões e a função <function>session_register</function>
   para registrar objetos, estes objetos são serializados automaticamente
   ao final de cada página PHP, e deserializados automaticamente no início das páginas seguintes.
   Isto basicamente significa que estes objetos podem ser utilizados em qualquer parte de 
   suas páginas por fazerem parte de sua sessão.
  </para>
  
  <para>
   É fortemente recomentado que você inclua a definição da classe de todos os objetos
   registrados em todas as páginas, mesmo que você não vá utilizá-lo em todas as suas páginas.
   Se você não o fizer e um objeto for deserializado sem sua classe definida, ele perderá a associação
   com a classe e se tornará um objeto do tipo <classname>__PHP_Incomplete_Class_Name</classname>
   sem nenhuma função disponível, ou seja, se tornará praticamente inútil.
  </para>
  
  <para>
   Então se no exemplo assima <varname>$a</varname> se tornar parte da sessão ao 
   se executar <literal>session_register("a")</literal>, você deve incluir o arquivo 
   <literal>classa.inc</literal> em todas as suas páginas, não somente em <filename>page1.php</filename> e
   <filename>page2.php</filename>.
  </para>
 </sect1>

 <sect1 xml:id="oop4.magic-functions">
  <title>As funções mágicas <literal>__sleep</literal> e <literal>__wakeup</literal></title>

  <para>
   <function>serialize</function> checks if your class has a function with
   the magic name <literal>__sleep</literal>. If so, that function is
   being run prior to any serialization. It can clean up the object
   and is supposed to return an array with the names of all variables
   of that object that should be serialized.
   If the method doesn't return anything then &null; is serialized and
   <constant>E_NOTICE</constant> is issued.
  </para>
  
  <para>
   The intended use of <literal>__sleep</literal> is to commit pending
   data or perform similar cleanup tasks. Also, the function is
   useful if you have very large objects which need not be
   saved completely.
  </para>
  
  <para>
   Conversely, <function>unserialize</function> checks for the
   presence of a function with the magic name 
   <literal>__wakeup</literal>. If present, this function can
   reconstruct any resources that object may have.
  </para>
  
  <para>
    The intended use of <literal>__wakeup</literal> is to
    reestablish any database connections that may have been lost
    during serialization and perform other reinitialization
    tasks.
  </para>
 </sect1>
  
 <sect1 xml:id="oop4.newref">
   <title>References inside the constructor</title>
   <para>
    Creating references within the constructor can lead to confusing
    results. This tutorial-like section helps you to avoid problems.
 
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class Foo {
    function Foo($name) {
        // create a reference inside the global array $globalref
        global $globalref;
        $globalref[] = &$this;
        // set name to passed value
        $this->setName($name);
        // and put it out
        $this->echoName();
    }

    function echoName() {
        echo "<br />", $this->name;
    }
 
    function setName($name) {
        $this->name = $name;
    }
}
?>
]]>
    </programlisting>
   </informalexample>
  </para>
    
   <para>
    Let us check out if there is a difference between
    <varname>$bar1</varname> which has been created using
    the copy <literal>=</literal> operator and
    <varname>$bar2</varname> which has been created using
    the reference <literal>=&amp;</literal> operator...

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
$bar1 = new Foo('set in constructor');
$bar1->echoName();
$globalref[0]->echoName();

/* output:
set in constructor
set in constructor
set in constructor */

$bar2 =& new Foo('set in constructor');
$bar2->echoName();
$globalref[1]->echoName();

/* output:
set in constructor
set in constructor
set in constructor */
?>
]]>
     </programlisting>
    </informalexample>
   </para>
   <para>
    Apparently there is no difference, but in fact there is a
    very significant one: <varname>$bar1</varname> and
    <varname>$globalref[0]</varname> are _NOT_ referenced, they
    are NOT the same variable. This is because "<literal>new</literal>" does not
    return a reference by default, instead it returns a copy.
    <note>
     <simpara>
      There is no performance loss (since PHP 4 and up use reference
      counting) returning copies instead of references. On the
      contrary it is most often better to simply work with copies
      instead of references, because creating references takes some
      time where creating copies virtually takes no time (unless none
      of them is a large array or object and one of them gets changed
      and the other(s) one(s) subsequently, then it would be wise to
      use references to change them all concurrently).
     </simpara>
    </note>
    To prove what is written above let us watch the code below.

    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
// now we will change the name. what do you expect?
// you could expect that both $bar1 and $globalref[0] change their names...
$bar1->setName('set from outside');

// as mentioned before this is not the case.
$bar1->echoName();
$globalref[0]->echoName();

/* output:
set from outside
set in constructor */

// let us see what is different with $bar2 and $globalref[1]
$bar2->setName('set from outside');

// luckily they are not only equal, they are the same variable
// thus $bar2->name and $globalref[1]->name are the same too
$bar2->echoName();
$globalref[1]->echoName();

/* output:
set from outside
set from outside */
?>
]]>
     </programlisting>
    </informalexample>   
   </para>   
   <para>
   Another final example, try to understand it.
   
    <informalexample>
     <programlisting role="php">
<![CDATA[
<?php
class A {
    function A($i) {
        $this->value = $i;
        // try to figure out why we do not need a reference here
        $this->b = new B($this);
    }

    function createRef() {
        $this->c = new B($this);
    }

    function echoValue() {
        echo "<br />","class ",get_class($this),': ',$this->value;
    }
}


class B {
    function B(&$a) {
        $this->a = &$a;
    }

    function echoValue() {
        echo "<br />","class ",get_class($this),': ',$this->a->value;
    }
}

// try to understand why using a simple copy here would yield
// in an undesired result in the *-marked line
$a =& new A(10);
$a->createRef();

$a->echoValue();
$a->b->echoValue();
$a->c->echoValue();

$a->value = 11;

$a->echoValue();
$a->b->echoValue(); // *
$a->c->echoValue();

?>
]]>
     </programlisting>
     &example.outputs;
     <screen>
<![CDATA[
class A: 10
class B: 10
class B: 10
class A: 11
class B: 11
class B: 11
]]>
     </screen>
    </informalexample>
   </para>
  </sect1>

  <sect1 xml:id="oop4.object-comparison">
   <title>Comparing objects</title>
  <para>
   In PHP 4, objects are compared in a very simple manner, namely: Two object
   instances are equal if they have the same attributes and values, and are
   instances of the same class. Similar rules are applied when comparing two
   objects using the identity operator (<literal>===</literal>).
  </para>
  <para>
   If we were to execute the code in the example below:
   <example>
    <title>Example of object comparison in PHP 4</title>
    <programlisting role="php">
<![CDATA[
<?php
function bool2str($bool) {
    if ($bool === false) {
            return 'FALSE';
    } else {
            return 'TRUE';
    }
}

function compareObjects(&$o1, &$o2) {
    echo 'o1 == o2 : '.bool2str($o1 == $o2)."\n";
    echo 'o1 != o2 : '.bool2str($o1 != $o2)."\n";
    echo 'o1 === o2 : '.bool2str($o1 === $o2)."\n";
    echo 'o1 !== o2 : '.bool2str($o1 !== $o2)."\n";
}

class Flag {
    var $flag;

    function Flag($flag=true) {
            $this->flag = $flag;
    }
}

class SwitchableFlag extends Flag {

    function turnOn() {
        $this->flag = true;
    }

    function turnOff() {
        $this->flag = false;
    }
}

$o = new Flag();
$p = new Flag(false);
$q = new Flag();

$r = new SwitchableFlag();

echo "Compare instances created with the same parameters\n";
compareObjects($o, $q);

echo "\nCompare instances created with different parameters\n";
compareObjects($o, $p);

echo "\nCompare an instance of a parent class with one from a subclass\n";
compareObjects($o, $r);
?>
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[    
Compare instances created with the same parameters
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : TRUE
o1 !== o2 : FALSE

Compare instances created with different parameters
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE

Compare an instance of a parent class with one from a subclass
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE
]]>
    </screen>
   </example>   
   Which is the output we will expect to obtain given the comparison rules
   above. Only instances with the same values for their attributes 
   and from the same class are considered equal and identical.
  </para>
  <para>
   Even in the cases where we have object composition, the same comparison
   rules apply. In the example below we create a container class that stores
   an associative array of <classname>Flag</classname> objects.
   <example>
    <title>Compound object comparisons in PHP 4</title>
    <programlisting role="php">
<![CDATA[
<?php
class FlagSet {
    var $set;

    function FlagSet($flagArr = array()) {
        $this->set = $flagArr;
    }

    function addFlag($name, $flag) {
        $this->set[$name] = $flag;
    }

    function removeFlag($name) {
        if (array_key_exists($name, $this->set)) {
            unset($this->set[$name]);
        }
    }
}


$u = new FlagSet();
$u->addFlag('flag1', $o);
$u->addFlag('flag2', $p);
$v = new FlagSet(array('flag1'=>$q, 'flag2'=>$p));
$w = new FlagSet(array('flag1'=>$q));

echo "\nComposite objects u(o,p) and v(q,p)\n";
compareObjects($u, $v);

echo "\nu(o,p) and w(q)\n";
compareObjects($u, $w);
?>     
]]>
    </programlisting>
    &example.outputs;
    <screen>
<![CDATA[
Composite objects u(o,p) and v(q,p)
o1 == o2 : TRUE
o1 != o2 : FALSE
o1 === o2 : TRUE
o1 !== o2 : FALSE

u(o,p) and w(q)
o1 == o2 : FALSE
o1 != o2 : TRUE
o1 === o2 : FALSE
o1 !== o2 : TRUE
]]>
    </screen>
   </example>
  </para>
 </sect1>
 </appendix>
 
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
