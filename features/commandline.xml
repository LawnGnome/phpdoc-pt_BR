<?xml version="1.0" encoding="UTF-8"?>
<!-- EN-Revision: n/a Maintainer: ae Status: ready -->
<chapter xml:id="features.commandline" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>Utilizando o PHP na linha de comando</title>
 <!-- NEW DOCUMENTATION STARTS -->
 <para>
  A partir versão 4.3.0, o PHP suporta um novo tipo
  <literal>SAPI</literal> (Server Application Programming Interface)
  chamado <literal>CLI</literal> que significa <emphasis>Command Line
  Interface</emphasis>. Como o próprio nome indica, essa <literal>SAPI</literal>
  tem foco no desenvolvimento de aplicações shell (ou no terminal/linha de comando) com
  o PHP. Há algumas diferenças entre a
  a <literal>CLI SAPI</literal> e outras <literal>SAPI</literal>s que são
  explicadas neste capítulo. Mas é errado dizer que
  a versão <literal>CLI</literal> e <literal>CGI</literal> são SAPIs
  diferentes pelo motivo que elas compartilham muitos comportamentos idênticos.
 </para>
 <para>
  A <literal>CLI SAPI</literal> foi liberada primeiramente com o
  PHP 4.2.0, mas ainda em estágio experimental, sendo necessário
  ativá-la explicitamente com a opção <option role="configure">--enable-cli</option> durante o
  <literal>./configure</literal>. Desde o PHP 4.3.0 a
  <literal>CLI SAPI</literal> não mais é experimental e a opção
  <option role="configure">--enable-cli</option> está ligada por default. você pode usar a opção
  <option role="configure">--disable-cli</option> para desativá-la.
 </para>
 <para>
  Desde o PHP 4.3.0, o nome, localização e existência dos executáveis CLI e CGI
  podem mudar dependendo de como o PHP foi instalado no seu sistema. Por padrão,
  quando executado o <command>make</command>, ambos CGI e CLI são compilados e
  colocados em <filename>sapi/cgi/php</filename> e <filename>sapi/cli/php</filename>,
  respectivamente, no seu diretório de fontes PHP. Note que que ambas tem
  o nome php. O que acontece durante o <command>make install</command> depende dos parâmetros do
  configure. Se o módulo SAPI é escolhido durante o configure, como o apxs, ou a opção
  <option role="configure">--disable-cgi</option> é utilizada, a versão CLI é copiada para
  <filename>{PREFIX}/bin/php</filename> durante o <command>make install</command>
  em vez da versão CGI ser colocada aqui. Então, por exemplo, se você tiver <option role="configure">--with--apxs
  </option> na sua linha de configuração, então a versão CLI é copiada para
  <filename>{PREFIX}/bin/php</filename> durante o <command>make
  install</command>. Se você quiser sobrescrever a instalação do executável CGI,
  use <command>make install-cli</command> depois do <command>make
  install</command>. Alternativamente, você pode especificar <option role="configure">
  --disable-cgi</option> em seu configure.
 </para>
 <para>
  <note>
   <para>
    Por serem ambos <option role="configure">--enable-cli</option> e
    <option role="configure">--enable-cgi</option> ligados por padrão,
    ter um <option role="configure">--enable-cli</option> em seu configure
    não significa necessariamente que a versão CLI será copiada para
    <filename>{PREFIX}/bin/php</filename> durante o <command>make install</command>.
   </para>
  </note>
 </para>
 <para>
  Os pacotes para Windows distribuidos entre o PHP 4.2.0 e PHP 4.2.3 forneciam a versão CLI
  com o nome <filename>php-cli.exe</filename>, na mesma pasta que a versão CGI
  <filename>php.exe</filename>. A partir do PHP 4.3.0, os pacotes Windows
  distribuem a versão CLI como <filename>php.exe</filename> em uma pasta separada,
  chamada <filename class="directory">cli</filename> ou seja: <filename>cli/php.exe
  </filename>. A partir do PHP 5, a versão CLI também é distribuída no diretório principal, com o nome
  <filename>php.exe</filename>. A versão CGI é distribuída com o nome
  <filename>php-cgi.exe</filename>.
 </para>
 <para>
  A partir do PHP 5, um novo arquivo <filename>php-win.exe</filename> começou a ser distribuído.
  Esta versão é igual a versão CLI, exceto que esse php-win não exibe nenhum
  output e também não disponibiliza nenhum console (nenhuma caixa de texto aparece na tela).
  Este comportamento é semelhante ao do php-gtk. Você pode configurar esse modo com
  <option role="configure">--enable-cli-win32</option>.
 </para>
 <para>
  <note>
   <title>Que versão de SAPI eu tenho?</title>
   <para>
    Na linha de comando, digitando <command>php -v</command>, ele lhe dirá
    se o <filename>php</filename> é CGI ou CLI. Veja também a função
    <function>php_sapi_name</function> e a constante <constant>
    PHP_SAPI</constant>.
   </para>
  </note>
 </para>
 <para>
  <note>
   <para>
    Um manual Unix <literal>man</literal> foi acrescentado no PHP 4.3.2. Você pode
    vê-lo digitando <command>man php</command> em seu ambiente shell.
   </para>
  </note>
 </para>
 <para>
  Diferenças importantes das <literal>CLI SAPI</literal> comparada com outras
  <literal>SAPI</literal>s:
  <itemizedlist>
   <listitem>
    <para>
     Diferentemente da <literal>CGI SAPI</literal>, nenhum header é impresso
     na saída.
    </para>
    <para>
     A <literal>CGI SAPI</literal> possui um meio de suprimir os headers
     HTTP, mas não há uma chave equivalente para ativá-los na <literal>CLI
     SAPI</literal>.
    </para>
    <para>
     A versão CLI é definida silenciosa por padrão. Mas as chaves <option>-q</option>
     e <option>--no-header</option> são mantidas para compatibilidade, de 
     forma que você possa utilizar scripts CGI antigos.
    </para>
    <para>
     Ela não altera o diretório de execução para o do script.
     (as chaves <option>-C</option> e <option>--no-chdir</option> também são mantidas para compatibilidade).
    </para>
    <para>
     Mensagens de erro em texto simples (sem formatação HTML).
    </para>
   </listitem>
   <listitem>
    <para>
     Estas são as diretivas do &php.ini; que são sobrescritas pela <literal>CLI
     SAPI</literal> porque não fazem sentido no ambiente shell:
    </para>
    <para>
     <table>
      <title>Diretivas &php.ini; sobrescritas</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Diretiva</entry>
         <entry>Valor default <literal>CLI SAPI</literal></entry>
         <entry>Comentários</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><link linkend="ini.html-errors">html_errors</link></entry>
         <entry>&false;</entry>
         <entry>
          Pode ser bem difícil de ler mensagens de erro no seu shell quando
          elas estão embebidas dentro de tags <literal>HTML</literal>,
          por isso essa diretiva tem default para &false;.
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.implicit-flush">implicit_flush</link></entry>
         <entry>&true;</entry>
         <entry>
          Essa diretiva causa que qualquer saída gerada de um
          <function>print</function>, <function>echo</function> e semelhantes sejam
          imediatamente escritas para o output e não cacheadas em nenhum buffer. Você
          ainda pode usar o <link linkend="ref.outcontrol">output buffering</link>
          se você precisa atrasar ou manipular a saída padrão.
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.max-execution-time">max_execution_time</link></entry>
         <entry>0 (unlimited)</entry>
         <entry>
          Devido as infinitas possibilidades da utilização do PHP em
          ambientes shell, o tempo máximo de execução foi configurado para
          ilimitado. Enquanto aplicações escritas para web são geralmente executadas
          em poucos segundos, aplicações no shell tendem a ter um tempo de execução
          mais longo.
         </entry>
        </row>
        <row>
         <entry><link linkend="ini.register-argc-argv">register_argc_argv</link></entry>
         <entry>&true;</entry>
         <entry>
         <para>
          Como essa diretiva é &true; você sempre terá acesso as variáveis
          <emphasis>argc</emphasis> (número de argumentos passados para a
          aplicação) e <emphasis>argv</emphasis> (array dos argumentos
          informados) na <literal>CLI SAPI</literal>.
         </para>
         <para>
          A partir do PHP 4.3.0, as variáveis do PHP <varname>$argc</varname>
          e <varname>$argv</varname> são registradas e preenchidas com os valores
          apropriados quando utilizando a <literal>CLI SAPI</literal>. Antes dessa versão,
          a criação dessas variáveis era controlada da mesma forma que as versões
          <literal>CGI</literal> e <literal>MODULE</literal>
          e precisava da diretiva PHP
          <link linkend="ini.register-globals">register_globals</link> configurada
          para <emphasis>on</emphasis>. Independentemente da versão ou da configuração
          de register_globals, você sempre poderá acessar esses dados através de
          <link linkend="reserved.variables.server">$_SERVER</link> ou
          <varname>$HTTP_SERVER_VARS</varname>. Exemplo:
          <varname>$_SERVER['argv']</varname>
         </para>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <note>
     <para>
      Estas diretivas não podem ser inicializadas com outros valores do
      arquivo de configuração &php.ini; ou um arquivo personalizado (se informado). Esta
      limitação existe porque estes valores são aplicados depois que todos
      os arquivos de configuração são analisados. Entretanto, seus valores podem ser modificados
      durante a execução (o que pode não fazer sentido para todas elas,
      por exemplo, <link linkend="ini.register-argc-argv">register_argc_argv</link>).
     </para>
    </note>
   </listitem>
   <listitem>
    <para>
     Para facilicar a operação no ambiente shell, as seguintes constantes
     estão definidas:
     <table>
      <title>Constantes específicas CLI</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Constante</entry>
         <entry>Descrição</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><constant>STDIN</constant></entry>
         <entry>
         Um stream já aberto para o <literal>stdin</literal>. Isto economiza
         ter de abrí-lo com 
         <programlisting role="php">
<![CDATA[
<?php

$stdin = fopen('php://stdin', 'r');

?>
]]>
         </programlisting>
         Se você precisa ler apenas uma linha do <literal>stdin</literal>, você pode
         utilizar
         <programlisting role="php">
<![CDATA[
<?php
$line = trim(fgets(STDIN)); // lê uma linha do STDIN
fscanf(STDIN, "%d\n", $number); // carrega number a partir do STDIN
?>
]]>
         </programlisting>
         </entry>
        </row>
        <row>
         <entry><constant>STDOUT</constant></entry>
         <entry>
         Um stream já aberto para o <literal>stdout</literal>. Isto economiza
         ter de abrí-lo com
         <programlisting role="php">
<![CDATA[
<?php

$stdout = fopen('php://stdout', 'w');

?>
]]>
         </programlisting>
         </entry>
        </row>
        <row>
         <entry><constant>STDERR</constant></entry>
         <entry>
         Um stream já aberto para o <literal>stderr</literal>. Isto economiza
         ter de abrí-lo com
         <programlisting role="php">
<![CDATA[
<?php

$stderr = fopen('php://stderr', 'w');

?>
]]>
         </programlisting>
         </entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </para>
    <para>
     Considerando isso, você não precisará mais abrí-los, por exemplo o
     <literal>stderr</literal> você mesmo, mas simplesmente usar a constante em vez
     do recurso stream:
     <programlisting role="shell">
<![CDATA[
php -r 'fwrite(STDERR, "stderr\n");'
]]>
     </programlisting>
     Você não precisa fechar explicitamente esses streams. Isto é realizado automaticamente
     pelo PHP.
    </para>
   </listitem>
   <listitem>
    <para>
     A <literal>CLI SAPI</literal> <emphasis
     role="strong">não</emphasis> modifica o diretório de execução atual para o diretório
     onde o script é interpretado!
    </para>
    <para>
     Exemplo mostrando a diferença da <literal>CGI SAPI</literal>:
     <programlisting role="php">
<![CDATA[
<?php
/* Nossa aplicação de teste chamada test.php */
echo getcwd(), "\n";
?>
]]>
     </programlisting>
    </para>
    <para>
     Quando utilizando a versão <literal>CGI</literal>, a saída é:
     <screen>
<![CDATA[
$ pwd
/tmp

$ php -q outro_diretorio/test.php
/tmp/outro_diretorio
]]>
     </screen>
     Isto mostra como o PHP modifica o diretório atual
     para aquela onde o script é executado.
    </para>
    <para>
     Utilizando a versão <literal>CLI SAPI</literal>:
     <screen>
<![CDATA[
$ pwd
/tmp

$ php -f outro_diretorio/test.php
/tmp
]]>
     </screen>
     E isto mostra a grande flexibilidade ferramentas shell em
     PHP.
    </para>
    <note>
     <para>
      A <literal>CGI SAPI</literal> suporta o comportamento da <literal>CLI SAPI</literal>
      utilizando a chave <option>-C</option> quando de sua execução na
      linha de comando.
     </para>
    </note>
   </listitem>
  </itemizedlist>
 </para>
 <para>
  A lista de opções de linha de comando fornecidas pelo binário do PHP
  pode ser solicitada a qualquer tempo executando o PHP com a
  opção <option>-h</option>:
  <screen>
<![CDATA[
Usage: php [options] [-f] <file> [args...]
       php [options] -r <code> [args...]
       php [options] [-- args...]
  -s               Display colour syntax highlighted source.
  -w               Display source with stripped comments and whitespace.
  -f <file>        Parse <file>.
  -v               Version number
  -c <path>|<file> Look for php.ini file in this directory
  -a               Run interactively
  -d foo[=bar]     Define INI entry foo with value 'bar'
  -e               Generate extended information for debugger/profiler
  -z <file>        Load Zend extension <file>.
  -l               Syntax check only (lint)
  -m               Show compiled in modules
  -i               PHP information
  -r <code>        Run PHP <code> without using script tags <?..?>
  -h               This help

  args...          Arguments passed to script. Use -- args when first argument
                   starts with - or script is read from stdin
]]>
  </screen>
 </para>
 <para>
  A <literal>CLI SAPI</literal> fornecer três maneiras diferentes para você
  executar seu código PHP:
  <orderedlist>
   <listitem>
    <para>
     Chamando o PHP para executar um arquivo determinado.
    </para>
    <para>
     <screen>
<![CDATA[
php my_script.php

php -f my_script.php
]]>
     </screen>
     De ambas maneiras (utilizando ou não a opção <option>-f</option>) o
     arquivo <filename>my_script.php</filename> é executado. Você pode escolher qualquer arquivo para
     executar --- seus scripts PHP não precisam terminar com a
     extensão <literal>.php</literal>, podendo ter qualquer nome ou extensão
     que você deseje.
    </para>
   </listitem>
   <listitem>
    <para>
     Passar o código PHP para execução diretamente a linha
     de comando.
    </para>
    <para>
     <screen>
<![CDATA[
php -r 'print_r(get_defined_constants());'
]]>
     </screen>
     É preciso ter especial cuidado com a substituição de variáveis shell e
     delimitação de strings utilizada.
    </para>
    <note>
     <para>
      Leia o exemplo cuidadosamente, observando que não há tags de abertura ou fechamento! A
      opção <option>-r</option> simplesmente não precisa delas. Utilizando-as você 
      obterá erros de interpretação.
     </para>
    </note>
   </listitem>
   <listitem>
    <para>
     Fornece código PHP para interpretação via a entrada padrão
     (<literal>stdin</literal>).
    </para>
    <para>
     Isto mostra a habilidade poderosa de como criar dinamicamente
     código PHP e fornecê-lo ao binário, como demonstrado
     neste exemplo (apenas demonstrativo):
     <screen>
<![CDATA[
$ alguma_aplicacao | algum_filtro | php | sort -u >final_output.txt
]]>
     </screen>
    </para>
   </listitem>
  </orderedlist>
  Você não pode combinar nenhum das três maneiras para executar código.
 </para>
 <para>
  Assim como qualquer aplicação shell, não somente o binário do PHP
  aceita um certo número de argumentos, mas também seu script PHP
  também pode recebê-los. O número de argumentos que podem ser passados para seu script
  não é limitado ao PHP (mas o shell tem um certo limite de tamanho
  em caracteres que podem ser informados, e não há um padrão para esse
  limite). Os argumentos passados para seu script são disponibilizados no array
  global <varname>$argv</varname>. No índice zero sempre conterá o nome do
  script (podendo ser <literal>-</literal> no caso de código PHP
  estar vindo da entrada padrão ou da opção de linha de comando
  <option>-r</option>). O segunda variável global
  <varname>$argc</varname> contém o número de elementos no
  array <varname>$argv</varname> (<emphasis role="strong">mas não</emphasis> o
  número de argumentos passados para seu script.
 </para>
 <para>
  Os argumentos que você deseja passar para seu script não podem começar com o caracter
  <literal>-</literal> e isso não pode ser modificado.
  Passando argumentos para seu script que comecem com um
  <literal>-</literal> causará problemas porque o PHP
  tentará manuseá-los. Para prevenir isso, utilize o separador de argumentos
  <literal>--</literal>. Depois que esse separador é passado para o
  PHP, todos os argumentos restantes são repassados
  intocados para seu script.
 </para>
 <para>
  <screen>
<![CDATA[
# Isto não executará o código fornecido e irá fazer o PHP mostrar sua ajuda
$ php -r 'var_dump($argv);' -h
Usage: php [options] [-f] <file> [args...]
[...]

# Isto passará o argumento '-h' para seu script e prevenirá o PHP de usá-lo
$ php -r 'var_dump($argv);' -- -h
array(2) {
  [0]=>
  string(1) "-"
  [1]=>
  string(2) "-h"
}
]]>
  </screen>
 </para>
 <para>
  Entretanto, há ainda uma outra maneira de se utilizar o PHP no
  shell. Você pode escrever um script que na primeira linha tenha
  <literal>#!/usr/bin/php</literal> e em seguida
  código PHP normal, incluindo as tags de
  início e fim do PHP. Você também precisa configurar os atributos de
  execução do arquivo (por exemplo, <command>chmod +x test</command>) de forma que seu script
  seja executado normalmente como um script shell/Perl:
  <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php
var_dump($argv);
?>
]]>
  </programlisting>
  Assumindo que o arquivo foi nomeado como <filename>teste</filename> e está no diretório
  atual, nós podemos fazer o seguinte:
  <screen>
<![CDATA[
$ chmod +x teste
$ ./test -h -- foo
array(4) {
  [0]=>
  string(6) "./teste"
  [1]=>
  string(2) "-h"
  [2]=>
  string(2) "--"
  [3]=>
  string(3) "foo"
}
]]>
  </screen>
  Como você viu, dessa forma não há problemas em passar parâmetros para seu script
  que comecem com o caracter <literal>-</literal>
 </para>
 <para>
  Opções com nomes "longos" foram disponibilizados a partir do PHP 4.3.3.
  <table>
   <title>Opções de linha de comando</title>
   <tgroup cols="2">
    <thead>
     <row>
      <entry>Opção</entry>
      <entry>Opção Longa</entry>
      <entry>Descrição</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>-s</entry>
      <entry>--syntax-highlight</entry>
      <entry>
       <para>
        Mostra o código fonte com destaque de cores.
       </para>
       <para>
        Esta opção usa o mecanismo interno para interpretar o arquivo e produzir
        uma versão <literal>HTML</literal> do fonte com destaque de cores e a envia para
        a saída padrão. Note que ele somente gerará blocos de
        <literal>&lt;code&gt; [...] &lt;/code&gt;</literal>,
        mas não headers <literal>HTML</literal>.
       </para>
       <note>
        <para>
         Esta opção não funciona juntamente com a opção <option>-r</option>.
         
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-s</entry>
      <entry>--syntax-highlighting</entry>
      <entry>
       <para>
        Apelido para <option>--syntax-highlight</option>.
       </para>
      </entry>
     </row>
     <row>
      <entry>-w</entry>
      <entry>--strip</entry>
      <entry>
       <para>
        Mostra o fonte sem comentários e espaços em branco.
       </para>
       <note>
        <para>
         Esta opção não funciona juntamente com a opção <option>-r</option>.

        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-f</entry>
      <entry>--file</entry>
      <entry>
       <para>
        Interpreta e executa o arquivo informado com a opção <option>-f</option>
        Esta diretiva é opcional e pode ser deixada de lado. Informar somente
        o nome do arquivo para execução é suficiente.
       </para>
      </entry>
     </row>
     <row>
      <entry>-v</entry>
      <entry>--version</entry>
      <entry>
       <para>
        Imprime as versões o PHP, PHP SAPI e Zend para a saída padrão, por exemplo:
        <screen>
<![CDATA[
$ php -v
PHP 4.3.0 (cli), Copyright (c) 1997-2002 The PHP Group
Zend Engine v1.3.0, Copyright (c) 1998-2002 Zend Technologies
]]>
        </screen>
       </para>
      </entry>
     </row>
     <row>
      <entry>-c</entry>
      <entry>--php-ini</entry>
      <entry>
       <para>
        Esta opção informa um diretório onde procurar pelo
        &php.ini; ou especifica um arquivo <literal>INI</literal> personalizado
        diretamente (não presisa ser obrigatoriamente &php.ini;), por exemplo:
        <screen>
<![CDATA[
$ php -c /custom/directory/ my_script.php

$ php -c /custom/directory/custom-file.ini my_script.php
]]>
        </screen>
        Se você não usar essa opção, o arquivo será procurado nos
        <link linkend="configuration.file">locais padrão</link>.
       </para>
      </entry>
     </row>
     <row>
      <entry>-n</entry>
      <entry>--no-php-ini</entry>
      <entry>
       <para>
        Ignora todo o &php.ini;. Esta chave está disponível desde o PHP 4.3.0.
       </para>
      </entry>
     </row>
     <row>
      <entry>-d</entry>
      <entry>--define</entry>
      <entry>
       <para>
        Esta opção permite definir um valor personalizado para qualquer diretiva
        de configuração permitida no &php.ini;. Sintaxe:
        <screen>
<![CDATA[
-d diretiva[=valor]
]]>
        </screen>
       </para>
       <para>
        Exemplos (linhas cortadas para melhor visualização):
        <screen>
<![CDATA[
# Omitindo a parte do valor irá configurar a diretiva para "1"
$ php -d max_execution_time 
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(1) "1"

# Passando um valor vazio irá configurar a diretiva para ""
php -d max_execution_time= 
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(0) ""

# A diretiva de configuração será preenchida com qualquer coisa informada depois do caracter =''
$  php -d max_execution_time=20 
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(2) "20"
$  php 
        -d max_execution_time=instonaofazsentido 
        -r '$foo = ini_get("max_execution_time"); var_dump($foo);'
string(15) "instonaofazsentido"
]]>
        </screen>
       </para>
      </entry>
     </row>
     <row>
      <entry>-a</entry>
      <entry>--interactive</entry>
      <entry>
       <para>
        Roda o PHP em modo interativo.
        <!--
        mfischer, 20020510: Couldn't come up with a decent useful description
        of the current implementation of the interactive mode.
        -->
       </para>
      </entry>
     </row>
     <row>
      <entry>-e</entry>
      <entry>--profile-info</entry>
      <entry>
       <para>
        Gera informações estendidas para o debugador/profiler.
        <!--
        mfischer, 20020510: Anyone who can provide more information what it
        really does (even if it's only for developers) ?
        -->
       </para>
      </entry>
     </row>
     <row>
      <entry>-z</entry>
      <entry>--zend-extension</entry>
      <entry>
       <para>
        Carrega a extensão Zend. Se somente o nome de arquivo é fornecido, o PHP tenta carregar
        essa extensão do caminho default de bibliotecas do seu sistema
        (geralmente especificado em <filename>/etc/ld.so.conf</filename> em sistemas
        Linux). Passando um nome de arquivo com o caminho absoluto irá evitar a
        procura no caminho das bibliotecas de sistema. Um nome de arquivo com uma
        informação de diretório relativa fará com que o PHP apenas tente
        carregar a extensão no caminho relativo ao diretório atual.
       </para>
      </entry>
     </row>
     <row>
      <entry>-l</entry>
      <entry>--syntax-check</entry>
      <entry>
       <para>
        Esta opção fornece uma maneira conveniente apenas realizar uma checagem de sintaxe
        no código PHP fornecido. No sucesso, o texto
        <literal>No syntax errors detected in &lt;arquivo&gt;</literal> é
        impresso na saída padrão e informado o código de saida de sistema
        <literal>0</literal>. Em caso de erro, o texto <literal>Errors parsing
        &lt;filename&gt;</literal> juntamente com o a mensagem do interpretador
        interno é impressa para a saída padrão e o código de saída de sistema é
        <literal>255</literal>.
       </para>
       <para>
        Esta opção não procura por erros fatais (como funções não definidas). Use
        <option>-f</option> se você deseja detectar erros fatais também.
       </para>
       <note>
        <para>
         Esta opção não trabalha com a opção <option>-r</option>

        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-m</entry>
      <entry>--modules</entry>
      <entry>
       <para>
        Utilizando essa opção, o PHP imprime os módulos PHP e Zend compilados
        (e carregados):
        <screen>
<![CDATA[
$ php -m
[PHP Modules]
xml
tokenizer
standard
session
posix
pcre
overload
mysql
mbstring
ctype

[Zend Modules]
]]>
        </screen>
       </para>
      </entry>
     </row>
     <row>
      <entry>-i</entry>
      <entry>--info</entry>
      <entry>
       Esta opção de linha de comando chama a função <function>phpinfo</function> e imprime
       seus resultados. Se o PHP não está funcionando bem, é
       interessante fazer um <command>php -i</command> para observar qualquer mensagem
       de erro impressa antes ou dentro das tabelas de informação.
       Utilizando o modo CGI o resultado impresso está em <literal>HTML</literal>, e
       ela por isso é um pouco grande.
      </entry>
     </row>
     <row>
      <entry>-r</entry>
      <entry>--run</entry>
      <entry>
       <para>
        Esta opção permite a execução de código PHP direto da
        linha de comando. As tags de início e fim do PHP
        (<literal>&lt;?php</literal> e <literal>?&gt;</literal>)
        <emphasis role="strong">não são</emphasis> necessárias e causarão erros
        de interpretação se informadas.
       </para>
       <note>
        <para>
         Cuidados deverão ser tomados utilizando dessa forma para
         evitar que haja substituição de variáveis pelo
         shell.
        </para>
        <para>
         Exemplo mostrando um erro de interpretação
         <screen>
<![CDATA[
$ php -r "$foo = get_defined_constants();"
Command line code(1) : Parse error - parse error, unexpected '='
]]>
         </screen>
         O problema aqui decorre do sh/bash realizar substituições de variáveis
         sempre quando se utilizam aspas (<literal>"</literal>). Desde que a
         variável <varname>$foo</varname> não deve estar definida, ela é
         substituída por nada o que faz que o código passado para o
         PHP para execução seja:
         <screen>
<![CDATA[
$ php -r " = get_defined_constants();"
]]>
         </screen>
         A maneira correta é utilizar apóstrofos (<literal>'</literal>).
         Variáveis em strings delimitadas por apóstrofos não são substituidas
         pelo sh/bash.
         <screen>
<![CDATA[
$ php -r '$foo = get_defined_constants(); var_dump($foo);'
array(370) {
  ["E_ERROR"]=>
  int(1)
  ["E_WARNING"]=>
  int(2)
  ["E_PARSE"]=>
  int(4)
  ["E_NOTICE"]=>
  int(8)
  ["E_CORE_ERROR"]=>
  [...]
]]>
         </screen>
         Se você estiver utilizando um shell diferente do sh/bash, você pode experimentar
         comportamentos diferenciados. Sinta-se livre para abrir um aviso de bug em
         <link xlink:href="&url.php.bugs;">&url.php.bugs;</link> ou enviar um e-mail para
         &email.php.doc;.

         Você vai rapidamente conseguir problemas quando tentar obter variáveis
         do ambiente dentro do código ou quando utilizar barras invertidas para escape. Esteja
         avisado. <!-- :-) -->
        </para>
       </note>
       <note>
        <para>
         <option>-r</option> está disponível na SAPI <emphasis>CLI</emphasis>
         SAPI mas não na SAPI <emphasis>CGI</emphasis>.
        </para>
       </note>
      </entry>
     </row>
     <row>
      <entry>-h</entry>
      <entry>--help</entry>
      <entry>
       Com essa opção, você pode obter informações sobre a lista atual de
       opções de linha de comando pequenas descrições sobre o que elas fazem.
      </entry>
     </row>
     <row>
      <entry>-?</entry>
      <entry>--usage</entry>
      <entry>
       Apelido para <option>--help</option>.
      </entry>
     </row>
     <!--
     new, not in PHP 4.3.4, but are in php_cli.c 1.102 or cgi_main.c 1.243
     -b <address:port>|<port> bindpath Bind Path for external FASTCGI Server mode, only CGI, no Windows
     -B <begin_code>     process-begin Run PHP <begin_code> before processing input lines
     -R <code>           process-code  Run PHP <code> for every input line
     -F <file>           process-file  Parse and execute <file> for every input line
     -E <end_code>       process-end   Run PHP <end_code> after processing all input lines
     -H                  hide-args     Hide any passed arguments from external tools.
     -g                  global        Define global variables on command line
     -->
    </tbody>
   </tgroup>
  </table>
 </para>
 <!-- NEW DOCUMENTATION ENDS -->

 <!-- OLD DOCUMENTED STARTS
  mfischer, 20020510: I've commented out the start paragraphs of the old
  documentation as it is meant to be replaced by the new one.
 <para>
  As opções de linha de comando para o executável do PHP são úteis
  se você deseja debugar ou testar a instalação do PHP, mas
  pode ser mais que isso, se você precisa utilizar o PHP para um
  propósito diferente do script para Web.
 </para>
 <para>
  Note que você sempre pode direcionar a saída do executável do PHP
  para um arquivo externo com o caracter &gt;,
  então <literal>php -q test.php &gt; test.html</literal>
  enviará todo a saída de <filename>test.php</filename>
  sem os headers HTTP para o arquivo <filename>test.html</filename>
  no mesmo diretório.
 </para>
 <para>
  Você só pode utilizar essas opções de linha de comando se você tiver
  o PHP executável. Se você compilou a versão módulo
  e não possui a versão CGI disponível em sua
  máquina, então você não poderá usar essas opções.
  Para os usuários Windows, tanto a versão executável e módulo do PHP
  então na distribuição binária, onde o executável é
  chamado <filename>php.exe</filename>.
 </para>
 -->
 <para>
  O PHP executável pode ser utilizando para rodar scripts PHP absolutamente
  independente de um servidor web. Se você está num sistema Unix, você pode acrescentar uma linha
  especial na primeira linha de seu script e torná-lo executável, então o sistema operacional
  saberá que programa deverá rodar o script. Na plataforma Windows, você pode
  associar <filename>php.exe</filename> com o clique duplo em arquivos
  <literal>.php</literal> ou fazer um arquivo batch para rodar
  seus scripts através do PHP. A primeira linha acrescentada ao script nos Unix não
  funcionam no Windows, por isso você não pode escrever programas independentes de plataforma
  desse jeito. Um exemplo simples de como escrever um programa para a linha de comando
  segue abaixo:
 </para>
 <para>
  <example>
   <title>Um script para rodar na linha de comando (script.php)</title>
   <programlisting role="php">
<![CDATA[
#!/usr/bin/php
<?php

if ($argc != 2 || in_array($argv[1], array('--help', '-help', '-h', '-?'))) {
?>

Este é um script de linha de comando com um parâmetro.

  Uso:
  <?php echo $argv[0]; ?> <opcao>

  <opcao> pode ser qualquer palavra que
  você queira imprimir. Com as opções --help, -help, -h
  ou -?, você pode obter essa ajuda.

<?php
} else {
    echo $argv[1];
}
?>
]]>
   </programlisting>
  </example>
 </para>
 <para>
  No script acima, nós utilizamos uma primeira linha especial para indicar
  que este arquivo precisa rodar pelo PHP. Como nós trabalhamos com a versão CLI
  aqui, não serão impressos headers HTTP. Há duas variáveis que você precisa conhecer para escrever aplicações
  em linha de comando com o PHP: <varname>$argc</varname> e
  <varname>$argv</varname>. O primeiro é o número de argumentos mais
  um (o nome do script executando). O segundo é um array
  contendo os argumentos, começando com o nome do script no índice
  zero (<varname>$argv[0]</varname>).
 </para>
 <para>
  No programa acima é verificado se há apenas um argumento
  fornecido. Se o argumento for <option>--help</option>,
  <option>-help</option>, <option>-h</option> ou <option>-?</option>,
  é impresso uma mensagem de ajuda, imprimindo o nome do script dinamicamente.
  Qualquer outro argumento é exibido como informado.
 </para>
 <para>
  Para rodar esse aplicativo nos Unix, basta torná-lo
  executável e o chamar diretamente como
  <command>script.php exibaisso</command> ou
  <command>script.php -h</command>. No Windows, você pode fazer um
  arquivo batch para esta tarefa:
 </para>
 <para>
  <example>
   <title>Arquivo batch para rodar um script em linha de comando (script.bat)</title>
   <programlisting role="winbat">
<![CDATA[
@c:\php\cli\php.exe script.php %1 %2 %3 %4
]]>
   </programlisting>
  </example>
 </para>
 <para>
  Assumindo que você nomeou o programa acima como
  <filename>script.php</filename>, e que tem sua versão
  CLI <filename>php.exe</filename> em
  <filename>c:\php\cli\php.exe</filename> este arquivo batch
  irá rodar com os seguintes parâmetros:
  <command>script.bat exibaisso</command> ou
  <command>script.bat -h</command>.
 </para>
 <para>
  Veja também a documentação da extensão <link linkend="ref.readline">Readline</link>
  para mais funções que você pode usar
  para incrementar suas aplicações para linha de comando em PHP.
 </para>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
